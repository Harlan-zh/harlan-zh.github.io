<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决ERROR 2006 (HY000): MySQL server has gone away]]></title>
    <url>%2Fposts%2Fmysql%2Fe5995b09.html</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;今天在做地址4级联动的时候，由于一次性全部取出数据导致报：SQLSTATE[HY000]: General error: 2006 MySQL server has gone away。于是在网上寻找相关的解决方案，发现是因为超过了mysql默认的数据包。 解决方案 登录mysql查询设置最大的数据包值1234567mysql&gt; show global variables like 'max_allowed_packet';+--------------------+---------+| Variable_name | Value |+--------------------+---------+| max_allowed_packet | 1048576 |+--------------------+---------+1 row in set (0.01 sec) 上限是1M，mysql的默认配置。 修改配置，设置为16M1set global max_allowed_packet=1024*1024*16; 注意：以上命令修改值针对当前有效，mysql重启后还会变成默认值1M。 永久有效，修改配置文件 my.ini1max_allowed_packet = 16M 参考 解决ERROR 2006 (HY000): MySQL server has gone away]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020最新PhpStorm激活码]]></title>
    <url>%2Fposts%2Fphpstorm%2F6608d634.html</url>
    <content type="text"><![CDATA[最新激活码有效期至2021年1月4号（亲测可用）特别感谢：桔子的桔子原文连接：2020年PHPstorm 最新激活码1QYYBAC9D3J-eyJsaWNlbnNlSWQiOiJRWVlCQUM5RDNKIiwibGljZW5zZWVOYW1lIjoi6LaF57qnIOeoi+W6j+WRmCIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAyMC0wMS0wNCIsInBhaWRVcFRvIjoiMjAyMS0wMS0wMyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjAyMC0wMS0wNCIsInBhaWRVcFRvIjoiMjAyMS0wMS0wMyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjAyMC0wMS0wNCIsInBhaWRVcFRvIjoiMjAyMS0wMS0wMyJ9XSwiaGFzaCI6IjE2MDgwOTA5LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-I7c5mu4hUCMxcldrwZEJMaT+qkrzrF1bjJi0i5QHcrRxk2LO0jqzUe2fBOUR4L+x+7n6kCwAoBBODm9wXst8dWLXdq179EtjU3rfJENr1wXGgtef//FNow+Id5iRufJ4W+p+3s5959GSFibl35YtbELELuCUH2IbCRly0PUBjitgA0r2y+9jV5YD/dmrd/p4C87MccC74NxtQfRdeUEGx87vnhsqTFH/sP4C2VljSo/F/Ft9JqsSlGfwSKjzU8BreYt1QleosdMnMK7a+fkfxh7n5zg4DskdVlNbfe6jvYgMVE16DMXd6F1Zhwq+lrmewJA2jPToc+H5304rcJfa9w==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow==]]></content>
      <categories>
        <category>phpstorm</category>
      </categories>
      <tags>
        <tag>phpstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JWT 学习笔记]]></title>
    <url>%2Fposts%2Fphp%2Fd9c65851.html</url>
    <content type="text"><![CDATA[简介&emsp;&emsp;JWT 是什么？JWT是json web token缩写。它将用户信息加密到token里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证token的正确性，只要正确即通过验证。基于token的身份验证可以替代传统的cookie+session身份验证方法。使用流程：初次登录：用户初次登录，输入用户名密码；密码验证：服务器从数据库取出用户名和密码进行验证；生成JWT：服务器端验证通过，根据从数据库返回的信息，以及预设规则，生成JWT；返还JWT：服务器的HTTP RESPONSE中将JWT返还；带JWT的请求：以后客户端发起请求，HTTP REQUEST；HEADER中的Authorizatio字段都要有值，为JWT；服务器验证JWT； JWTJWT由三个部分组成：header.payload.signature header1234&#123; "alg": "HS256", "typ": "JWT"&#125; 说明：该字段为json格式。alg：字段指定了生成signature的算法，默认值为：HS256，typ：默认值为：JWT payload12345&#123; "sub": "1234567890", "name": "John Doe", "iat": 1516239022&#125; 说明：该字段为json格式，表明用户身份的数据，可以自己自定义字段，很灵活。sub 面向的用户name 姓名iat 签发时间官方提供字段示例如下：undefined signature12345HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret) 说明：将前两部分进行base64编码后使用.拼接成待加密字符串，secret是加密的密钥；加密方式需要在 header 指定，有好多种：HS256，HS384，RS256 等。 实践代码注意：php版本 &gt;= 7.0.* 类封装：jwt.class.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;?php/** * PHP实现jwt * 作者：https://segmentfault.com/a/1190000016251365 */class Jwt &#123; //头部 private static $header=array( 'alg'=&gt;'HS256', //生成signature的算法 'typ'=&gt;'JWT' //类型 ); //使用HMAC生成信息摘要时所使用的密钥 private static $key='123456'; /** * 获取jwt token * @param array $payload jwt载荷 格式如下非必须 * [ * 'iss'=&gt;'jwt_admin', //该JWT的签发者 * 'iat'=&gt;time(), //签发时间 * 'exp'=&gt;time()+7200, //过期时间 * 'nbf'=&gt;time()+60, //该时间之前不接收处理该Token * 'sub'=&gt;'www.admin.com', //面向的用户 * 'jti'=&gt;md5(uniqid('JWT').time()) //该Token唯一标识 * ] * @return bool|string */ public static function getToken(array $payload) &#123; if(is_array($payload)) &#123; $base64header=self::base64UrlEncode(json_encode(self::$header,JSON_UNESCAPED_UNICODE)); $base64payload=self::base64UrlEncode(json_encode($payload,JSON_UNESCAPED_UNICODE)); $token=$base64header.'.'.$base64payload.'.'.self::signature($base64header.'.'.$base64payload,self::$key,self::$header['alg']); return $token; &#125;else&#123; return false; &#125; &#125; /** * 验证token是否有效,默认验证exp,nbf,iat时间 * @param string $Token 需要验证的token * @return bool|string */ public static function verifyToken(string $Token) &#123; $tokens = explode('.', $Token); if (count($tokens) != 3) return false; list($base64header, $base64payload, $sign) = $tokens; //获取jwt算法 $base64decodeheader = json_decode(self::base64UrlDecode($base64header), JSON_OBJECT_AS_ARRAY); if (empty($base64decodeheader['alg'])) return false; //签名验证 if (self::signature($base64header . '.' . $base64payload, self::$key, $base64decodeheader['alg']) !== $sign) return false; $payload = json_decode(self::base64UrlDecode($base64payload), JSON_OBJECT_AS_ARRAY); //签发时间大于当前服务器时间验证失败 if (isset($payload['iat']) &amp;&amp; $payload['iat'] &gt; time()) return false; //过期时间小宇当前服务器时间验证失败 if (isset($payload['exp']) &amp;&amp; $payload['exp'] &lt; time()) return false; //该nbf时间之前不接收处理该Token if (isset($payload['nbf']) &amp;&amp; $payload['nbf'] &gt; time()) return false; return $payload; &#125; /** * base64UrlEncode https://jwt.io/ 中base64UrlEncode编码实现 * @param string $input 需要编码的字符串 * @return string */ private static function base64UrlEncode(string $input) &#123; return str_replace('=', '', strtr(base64_encode($input), '+/', '-_')); &#125; /** * base64UrlEncode https://jwt.io/ 中base64UrlEncode解码实现 * @param string $input 需要解码的字符串 * @return bool|string */ private static function base64UrlDecode(string $input) &#123; $remainder = strlen($input) % 4; if ($remainder) &#123; $addlen = 4 - $remainder; $input .= str_repeat('=', $addlen); &#125; return base64_decode(strtr($input, '-_', '+/')); &#125; /** * HMACSHA256签名 https://jwt.io/ 中HMACSHA256签名实现 * @param string $input 为base64UrlEncode(header).".".base64UrlEncode(payload) * @param string $key * @param string $alg 算法方式 * @return mixed */ private static function signature(string $input, string $key, string $alg = 'HS256') &#123; $alg_config=array( 'HS256'=&gt;'sha256' ); return self::base64UrlEncode(hash_hmac($alg_config[$alg], $input, $key,true)); &#125;&#125; 调用：1234567891011121314151617181920212223&lt;?php/** * PHP实现jwt * 作者：https://segmentfault.com/a/1190000016251365 */require "jwt.class.php";$payload_test=array( 'iss' =&gt; 'admin', 'iat' =&gt; time(), 'exp' =&gt; time()+7200, 'nbf' =&gt; time(), 'sub' =&gt; 'www.admin.com', 'jti' =&gt; md5(uniqid('JWT').time()));$token_test = Jwt::getToken($payload_test);echo $token_test;echo "&lt;br&gt;";// 验证token签名$getPayload_test=Jwt::verifyToken($token_test);var_dump($getPayload_test); 参考 php 后端实现JWT认证方法]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习之路]]></title>
    <url>%2Fposts%2Fgit%2F113d1d94.html</url>
    <content type="text"><![CDATA[简介Git是一个免费的开源 分布式版本控制系统，旨在快速，高效地处理从小型到大型项目的所有事务。Git 易于学习， 占地面积小，具有闪电般快速的性能。它超越了Subversion，CVS，Perforce和ClearCase等SCM工具，具有廉价的本地分支，便捷的临时区域和 多个工作流程等功能。 Download 下载下载地址：官网git download 官方文档：Documentation 提示：具体的安装方法去看一下 官方文档 ，里面写的安装步骤很详细。 命令行使用 GIT直接在已有项目的文件里提交项目进入到项目文件夹下，打开 cmd 命令行 提示：这里推荐大家使用 cmder 命令行工具，个人感觉在敲命令的时候很舒服。 初始化 1git init 这个时候你会在你的项目文件夹下面看到一个 .git 的隐藏文件 提示：看不到说明你没勾选文件夹 隐藏的项目 。 点击文件夹上面的 查看 -&gt; 隐藏的项目（勾选上） 和远程建立连接 1git remote add &lt;dev&gt; &lt;url&gt; dev ：远程仓库的名字（别名，随便起） url ：远程仓库的地址（https ， ssh 都行） 获取远程分支 1git fetch &lt;dev&gt; dev ：上一步仓库的别名 查看远程分支 1git branch -a 将远程的分支检出到本地并切换到新的分支 1git checkout -b &lt;thisBranch&gt; &lt;dev&gt;/&lt;branchName&gt; -b ：新建一个分支并同时切换到那个分支上 thisBranch ：本地分支的名称 dev ：远程仓库别名 branchName ：远程分支名称 提示：这一步建议 thisBranch 和 branchName 保持一致注意：如果出现 fatal: ‘thisBranch’ is not a commit and a branch ‘thisBranch’ cannot be created from it 错误，说明远程分支不存在，仔细检测一下 &lt;dev&gt;/&lt;branchName&gt;。 这个时候我们可以使用 git status 查看当前仓库那些文件没有被跟踪和变化。 添加未跟踪的文件为跟踪状态 1git add . . ：当前仓库所有未跟踪的文件 提交 1git commit -m "commit content" -m ： 本次提交的内容 这里 7，8 可以合并成一句执行，但是这里只能提交未跟踪的文件，已跟踪的文件修改后将不会被提交git commit -a -m &quot;commit content&quot; 推送到远程仓库 1git push 这个时候我们在浏览器上打开远程仓库可以看到刚刚提交的内容了。 通过远程拉取代码时，这里使用的是 clone 的方式 新建一个干净的文件夹并且进入到该文件夹，执行下面的命令 1git clone &lt;url&gt; url ： 远程项目仓库的地址 查看远程仓库的分支 1git branch -a 拉取远程分支到本地并自动切换到该分支 1git checkout -b &lt;thisBranch&gt; &lt;dev&gt;/&lt;branchName&gt; 这里我就不多做解释了，在文章的上面都有想对应的说明。 下面就可以开始你的项目开发了。 注意：提交后别忘记 push ，否则无法把最新的代码推送到远程仓库里去 参考 git官方文档 git 拉取远程指定分支 pull本地不存在的分支 git命令－切换分支 为已经存在的本地项目添加git，以及从远程仓库拉取代码并切换远程分支]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP使用ffmpeg实现截取视频封面图]]></title>
    <url>%2Fposts%2Fffmpeg%2F4ef34b77.html</url>
    <content type="text"><![CDATA[前言本篇文章将带您学习如何使用 ffmpeg 实现截取视频封面图保存到本地，以及在 Linux 安装ffmpeg 的过程。 ffmpeg 介绍ffmpeg 是一个很强大的音视频处理工具，官网 介绍ffmpeg是：一个完整的、跨平台的解决方案，可以记录、转换和传输音频和视频。ffmpeg 既可以播放视频，也提供命令行工具来处理视频，另外还有强大的视频处理库用于开发。 Linux 安装 ffmpeg下载安装 ffmpeg去 ffmpeg 官网 下载4.0.3 安装包。 下载之后上传至Linux准备安装，首先解压安装包 123tar -xjvf ffmpeg-3.3.1.tar.bz2cd ffmpeg-3.3.1/./configure --enable-shared --prefix=/monchickey/ffmpeg 注意：如果现在直接执行configure配置的话，可能会报如下的错误：yasm/nasm not found or too old. Use –disable-yasm for a crippled build.错误的意思是 yasm/nasm 包不存在或者很旧，可以使用--disable-yasm禁用这个选项编译也可以按照下面的步骤进行安装yasm。 下载安装 yasm yasm是一款汇编器，并且是完全重写了nasm的汇编环境，接收nasm和gas语法，支持x86和amd64指令集。 安装yasm：yasm 安装地址 下载完成后传到服务器上进行安装，下面是安装方法（这里我安装的是 1.3.0） 12345tar -xvzf yasm-1.3.0.tar.gzcd yasm-1.3.0/./configuremakemake install 编译参数都是默认的，直接安装到系统中即可。 继续安装 ffmpegyasm安装成功之后继续回到ffmpeg解压后的目录，执行下面命令编译并安装：123./configure --enable-shared --prefix=/monchickey/ffmpegmakemake install 这个编译的过程时间可能有点长，这时候我们可以去泡杯咖啡了。 安装完成之后进入到安装目录：cd /monchickey/ffmpeg/.├─ ffmpeg├─── bin // ffmpeg主程序二进制目录├─── include // C/C++头文件目录├─── lib // 编译好的库文件目录├─── share // 文档目录进入bin目录，执行 ./ffmpeg -version 查看当前版本的详细信息 默认情况下一般会报：libavdevice.so.57: cannot open shared object file: No such file or directory 原因是lib目录未加载到链接到系统库中，系统ld目录列表在/etc/ld.so.conf中，打开文件会发现，里面引用了/etc/ld.so.conf.d/下面所有的.conf文。 这时我们只需要创建一个文件并写入lib路径即可，执行命令：vim /etc/ld.so.conf.d/ffmpeg.conf 然后添加一行内容：/monchickey/ffmpeg/lib 之后保存并退出，然后执行 ldconfig 使配置生效，现在再次执行 ./ffmpeg -version 显示就正常了提示：可以根据需要将bin目录添加至环境变量中以保证任何时候都能使用ffmpeg命令 使用php代码实现视频封面图截取123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * 上传视频 * @return 视频路径 */function upload_video()&#123; if ($_FILES["file"]["error"] &gt; 0) &#123; $api-&gt;dataerror('视频上传错误!'); &#125; else &#123; $type = [ "video/rmvb", "video/wmv", "video/3gp", "video/mkv", "video/mp4", "video/mpg", "video/avi", "video/quicktime", "multipart/video", ]; if (in_array($_FILES["file"]["type"], $type)) &#123; if($_FILES["file"]["size"] &lt;= 20 * 1024 * 1024) &#123; $upload_path = 'uploads/video/file_name'; //建立文件夹 create($upload_path); $file_name = md5(uniqid(rand())); // 文件随机名字 $file_ext = strtolower(substr($_FILES["file"]["name"], strrpos($_FILES["file"]["name"], ".") + 1, strlen($_FILES["file"]["name"]))); // 获取文件后缀 $upload_path_file = $upload_path . $file_name . '.' . $file_ext; if (file_exists($upload_path_file)) &#123; echo '视频文件名以被占用, 请重新上传!'; &#125; else &#123; if (move_uploaded_file($_FILES["file"]["tmp_name"], $upload_path_file)) &#123; $video_path = $upload_path_file; // 视频路径 $item['video_path'] = $video_path; $face_name = $upload_path . $file_name . '.' . 'png'; //视频封面图 $pic_size = getVideoInfo($video_path); if ($pic_size['2'] &gt; 0) &#123; $str = "/monchickey/ffmpeg/bin/ffmpeg -i " . $video_path . " -y -f mjpeg -ss 1 -t 0.001 -s " . $pic_size[1] . "x" . $pic_size[0] . " " . $face_name; &#125; else &#123; $str = "/monchickey/ffmpeg/bin/ffmpeg -i " . $video_path . " -y -f mjpeg -ss 1 -t 0.001 -s " . $pic_size[0] . "x" . $pic_size[1] . " " . $face_name; &#125; system($str); if (file_exists($face_name)) &#123; $item['video_face_image'] = $name; &#125;else &#123; echo "视频封面图截取失败!"; &#125; return $item; &#125; else &#123; echo "视频文件上传失败!"; &#125; &#125; &#125;else &#123; echo "视频最大不能超过20M!"; &#125; &#125; else &#123; echo "视频格式错误!"; &#125; &#125;&#125;/** * 创建文件夹 * @param $dir 文件夹路径 */function create($dir)&#123; if( !is_dir($dir) )&#123; $temp = explode('/',$dir); $cur_dir = ''; for($i = 0; $i &lt; count($temp); $i++)&#123; $cur_dir .= $temp[$i].'/'; if(!is_dir($cur_dir))&#123; @mkdir($cur_dir,0777); &#125; &#125; &#125;&#125;/** * 处理视频文件文件截取封面图的信息 * @param $file 视频文件路径 */function getVideoInfo($file)&#123; $command = sprintf('/monchickey/ffmpeg/bin/ffmpeg -i "%s" 2&gt;&amp;1', $file); ob_start(); passthru($command); $info = ob_get_contents(); ob_end_clean(); if (preg_match("/Video: (.*?),(.*?),(.*?),(.*?),(.*?),(.*?),(.*?),(.*?)[,\s]/", $info, $match)) &#123; foreach ($match as $k =&gt; $m) &#123; if (strstr($m, 'x') &amp;&amp; $k &gt; 0) &#123; $size1 = explode('x', trim($m)); if (preg_match("/^\d*$/", $size1[0])) &#123; $size[0] = $size1[0]; if (preg_match("/^\d*$/", $size1[1])) &#123; $size[1] = $size1[1]; &#125; else &#123; $size2 = explode(' ', trim($size1[1])); $size[1] = $size2[0]; &#125; &#125; &#125; &#125; &#125; if (preg_match("/Side data:[,\s]/", $info, $match2)) &#123; $size[2] = 1; &#125; return $size;&#125; 参考 博客园 - 自由的web]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpstorm配置Xdebug]]></title>
    <url>%2Fposts%2Fxdebug%2F8d586dc9.html</url>
    <content type="text"><![CDATA[前言相信做为一名PHP开发的程序员对sublime这个编辑器不陌生吧，我之前用的就是这个编辑器，在每次有BUG反馈过来的时候，我都是用die去一步一步的断点打印输出找错误，看着是不是就很痛苦。后来知道了 phpstorm + xdebug，欣喜若狂，这简直是款调试代码的神器呀，幸福来的好突然。后来这篇文章就诞生了。 声明本篇文章将讲述的是如何使用 xdebug 配合 phpstorm 编辑器调试PHP程序 兼容 postman 什么是Xdebug?Xdebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况。 下载安装 下载 phpstorm 至于怎么去破解我想 这里 可以帮助你 下载对应版本的 Xdebug扩展 开始配置配置编辑器的php打开已经破解好的 phpstorm 的设置，找到 Languages &amp; Frameworks -&gt; PHP 选择自己当前正在使用的版本。 配置ServersName 随便填写，Host 和 Port 填写自己需要调试的项目域名以及端口，Debugger 默认的Xdebug就行 点击 Languages &amp; Frameworks -&gt; PHP -&gt; Debug 将Debug port 修改为 9001 点击 Languages &amp; Frameworks -&gt; PHP -&gt; Debug -&gt; DBGp Proxy 将IDE KEY换成当前PHP的IDE KEY填上自己网站的 host 和 port 查看IDE KEY需要打印自己的PHP信息echo phpinfo();然后在这里面找IDE KEY 配置 php.ini打开 php.ini 在最底部添加以下代码 1234567891011121314[xdebug]; XDEBUG Extension DLLzend_extension ="D:/wamp64/bin/php/php5.6.31/zend_ext/php_xdebug-2.5.5-5.6-vc11-x86_64.dll";xdebug.idekey="PHPSTORM"xdebug.remote_enable = onxdebug.profiler_enable = offxdebug.profiler_enable_trigger = offxdebug.profiler_output_name = cachegrind.out.%t.%pxdebug.profiler_output_dir ="D:/wamp64/tmp"xdebug.show_local_vars=0xdebug.remote_handler = dbgp; 设置xdebug的端口为9001, 要和编辑器设置的一致哦xdebug.remote_port = "9001" 安装chrome xdebug helper 扩展扩展地址： xdebug helper 运行监听配置（这步配置配置的是为了编辑器里的run需要的，在postman调试可以忽略此步骤）按照下图的配置完成后点击OK 开启监听 点击上面带虫子的小话筒 运行点击编辑器上面的小瓢虫，这时会自动弹出编辑器代码断点的地方，并打印了上面的变量 兼容 postman在项目中使用 postman 调试的时候在 header 添加如下配置 12KEY : CookieVALUE : XDEBUG_SESSION=PHPSTORM 点击 Send 后效果跟上面是一样的，自动弹出编辑器跳到断点的地方。]]></content>
      <categories>
        <category>xdebug</category>
      </categories>
      <tags>
        <tag>phpstorm</tag>
        <tag>Xdebug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装配置hexo，部署+next主题]]></title>
    <url>%2Fposts%2Fhexo%2Fc14c7c98.html</url>
    <content type="text"><![CDATA[文章由来 以前没有写博客的习惯，也没写过几篇博客。之前有一次工作中找同事问一个前端问题，跑到他的办公桌前偶然的发现了这个”东西”。第一眼看上去给我的个人感觉很好，经过我对同事的仔细盘问后，在加以私下的了解，才知道这个博客是用 hexo (访问缓慢并且无样式，好像已弃用，最新的地址 hexo ) + next主题 搭建的。废话不多说了，Follow Me ! 安装安装前提在安装前，先确保电脑上已经安装了 Node.js 和 Git 环境。 安装Hexo1$ npm install -g hexo-cli 文档上是使用npm安装的，也有人用 yarn 安装的，博主说使用 yarn 安装要比 npm 要好，具体好在什么地方倒没试过。使用 yarn 安装的博主连接 ：代码小睿 。 建站初始化新建一个文件夹，名字随便起，比如我的叫 blog进入到新建的文件夹输入以下命令 1$ hexo init 初始化完成后，你会看到这样的一个文件目录结构 创建一个文件1$ hexo new post 第一篇文章 //在_post文件夹下创建一个名为 《第一篇文章》 的文件 生成静态文件1$ hexo generate // 可以简写成 hexo g 启动服务1$ hexo server // 可以简写成 hexo s 以上命令会生成一个 localhost:4000 的连接， 打开连接会看到自己博客的首页。 部署到线上GitHub 和 Gitee都支持Hexo静态网站的服务，我用的是Gitee。 首先到你的GitHub 或 Gitee 上去建立一个仓库，仓库名称最好是你自己的英文名称或者自创的名称，仓库创建好后，复制仓库的地址 打开本地的 _config.yml 配置文件，找到最下面的 deploy 选项. 123deploy: type: git repo: https://gitee.com/***/*** // 刚刚创建的仓库连接地址 注意：冒号后面一定要有一个空格 安装 hexo-deployer-git 自动部署工具。 1$ npm install hexo-deployer-git --save 上传到线上安装完成自动部署工具后，使用命令上传到线上 1$ hexo deploy // 简写 hexo d 第一次上传会提示你输入GitHub 或者 Gitee 的账号密码，确认后等待一会会提示你发布成功；这时打开码云，找到刚刚项目分支，点击服务选择Gitee Pages，然后就可以看到线上的一个连接。点击进入连接 https://hsweet.gitee.io 就可以看到线上的博客了。 主题安装Next主题1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 我安装的是 6.0.x 的 NexT ，但在 NexT 官网上提供的还是 5.1.x 的安装命令和文档，因为 6.0.x 和 5.1.x 的配置有所不同，建议第一次练习搭建还是使用 5.1.x ，熟悉配置文档后，再用 6.0.x 。 修改 _config.yml 文件里 theme 配置： 1theme: next 配置虽然我安装的是 6.0.x ，但大部分还是可以根据 NexT 主题配置 文档来修改，以下会介绍一些文档中没有提及的设置。 区分两个配置文件 :站点配置文件 _config.yml主题配置文件 themes/next/_config.yml 设置网站语言打开 站点配置 找到 language 修改 1language: zh-CN 开启导航打开 主题配置 找到 menu ，将需要开启的导航前面的 # 删掉 123456789menu: home: / || home // 首页 about: /about/ || user // 关于我 tags: /tags/ || tags // 标签 categories: /categories/ || th // 分类 archives: /archives/ || archive // 归档 #schedule: /schedule/ || calendar // 日程表 #sitemap: /sitemap.xml || sitemap // 站点地图 commonweal: /404.html || heartbeat // 404公益 这个时候会发现网站上已经能看到导航了，但点击却提示找不到页面。 这时需要去新建对应的页面，比如新建 标签 页： 1$ hexo new page "tags" 新建好后会在 source/tags/index.md 看到刚新建的文件，在文件随便增加一句话重新编译生成试试。 更多配置请参考文档 : Next主题官方文档 总结每次新建的页面文件，修改文件 或 修改配置的时候只需要以下三个命令就ok了（甚至我觉得只需要这三个命令就行了） 12345$ hexo generate // 编译 简写: hexo g$ hexo server // 生成临时文件并给出一个本地连接 简写: hexo s$ hexo deploy // 把临时生成的文件上传到服务器 参考 Hexo文档 Next主题文档 搭建hexo + next主题博客教程]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
