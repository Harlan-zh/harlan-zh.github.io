<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git学习之路]]></title>
    <url>%2Fposts%2Fgit%2F113d1d94.html</url>
    <content type="text"><![CDATA[简介Git是一个免费的开源 分布式版本控制系统，旨在快速，高效地处理从小型到大型项目的所有事务。Git 易于学习， 占地面积小，具有闪电般快速的性能。它超越了Subversion，CVS，Perforce和ClearCase等SCM工具，具有廉价的本地分支，便捷的临时区域和 多个工作流程等功能。 Download 下载下载地址：官网git download 官方文档：Documentation 提示：具体的安装方法去看一下 官方文档 ，里面写的安装步骤很详细。 命令行使用 GIT直接在已有项目的文件里提交项目进入到项目文件夹下，打开 cmd 命令行 提示：这里推荐大家使用 cmder 命令行工具，个人感觉在敲命令的时候很舒服。 初始化 1git init 这个时候你会在你的项目文件夹下面看到一个 .git 的隐藏文件 提示：看不到说明你没勾选文件夹 隐藏的项目 。 点击文件夹上面的 查看 -&gt; 隐藏的项目（勾选上） 和远程建立连接 1git remote add &lt;dev&gt; &lt;url&gt; dev ：远程仓库的名字（别名，随便起） url ：远程仓库的地址（https ， ssh 都行） 获取远程分支 1git fetch &lt;dev&gt; dev ：上一步仓库的别名 查看远程分支 1git branch -a 将远程的分支检出到本地并切换到新的分支 1git checkout -b &lt;thisBranch&gt; &lt;dev&gt;/&lt;branchName&gt; -b ：新建一个分支并同时切换到那个分支上 thisBranch ：本地分支的名称 dev ：远程仓库别名 branchName ：远程分支名称 提示：这一步建议 thisBranch 和 branchName 保持一致注意：如果出现 fatal: ‘thisBranch’ is not a commit and a branch ‘thisBranch’ cannot be created from it 错误，说明远程分支不存在，仔细检测一下 &lt;dev&gt;/&lt;branchName&gt;。 这个时候我们可以使用 git status 查看当前仓库那些文件没有被跟踪和变化。 添加未跟踪的文件为跟踪状态 1git add . . ：当前仓库所有未跟踪的文件 提交 1git commit -m "commit content" -m ： 本次提交的内容 这里 7，8 可以合并成一句执行，但是这里只能提交未跟踪的文件，已跟踪的文件修改后将不会被提交git commit -a -m &quot;commit content&quot; 推送到远程仓库 1git push 这个时候我们在浏览器上打开远程仓库可以看到刚刚提交的内容了。 通过远程拉取代码时，这里使用的是 clone 的方式 新建一个干净的文件夹并且进入到该文件夹，执行下面的命令 1git clone &lt;url&gt; url ： 远程项目仓库的地址 查看远程仓库的分支 1git branch -a 拉取远程分支到本地并自动切换到该分支 1git checkout -b &lt;thisBranch&gt; &lt;dev&gt;/&lt;branchName&gt; 这里我就不多做解释了，在文章的上面都有想对应的说明。 下面就可以开始你的项目开发了。 注意：提交后别忘记 push ，否则无法把最新的代码推送到远程仓库里去 参考 git官方文档 git 拉取远程指定分支 pull本地不存在的分支 git命令－切换分支 为已经存在的本地项目添加git，以及从远程仓库拉取代码并切换远程分支]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP使用ffmpeg实现截取视频封面图]]></title>
    <url>%2Fposts%2Fffmpeg%2F4ef34b77.html</url>
    <content type="text"><![CDATA[前言本篇文章将带您学习如何使用 ffmpeg 实现截取视频封面图保存到本地，以及在 Linux 安装ffmpeg 的过程。 ffmpeg 介绍ffmpeg 是一个很强大的音视频处理工具，官网 介绍ffmpeg是：一个完整的、跨平台的解决方案，可以记录、转换和传输音频和视频。ffmpeg 既可以播放视频，也提供命令行工具来处理视频，另外还有强大的视频处理库用于开发。 Linux 安装 ffmpeg下载安装 ffmpeg去 ffmpeg 官网 下载4.0.3 安装包。 下载之后上传至Linux准备安装，首先解压安装包 123tar -xjvf ffmpeg-3.3.1.tar.bz2cd ffmpeg-3.3.1/./configure --enable-shared --prefix=/monchickey/ffmpeg 注意：如果现在直接执行configure配置的话，可能会报如下的错误：yasm/nasm not found or too old. Use –disable-yasm for a crippled build.错误的意思是 yasm/nasm 包不存在或者很旧，可以使用--disable-yasm禁用这个选项编译也可以按照下面的步骤进行安装yasm。 下载安装 yasm yasm是一款汇编器，并且是完全重写了nasm的汇编环境，接收nasm和gas语法，支持x86和amd64指令集。 安装yasm：yasm 安装地址 下载完成后传到服务器上进行安装，下面是安装方法（这里我安装的是 1.3.0） 12345tar -xvzf yasm-1.3.0.tar.gzcd yasm-1.3.0/./configuremakemake install 编译参数都是默认的，直接安装到系统中即可。 继续安装 ffmpegyasm安装成功之后继续回到ffmpeg解压后的目录，执行下面命令编译并安装：123./configure --enable-shared --prefix=/monchickey/ffmpegmakemake install 这个编译的过程时间可能有点长，这时候我们可以去泡杯咖啡了。 安装完成之后进入到安装目录：cd /monchickey/ffmpeg/.12345├─ ffmpeg├─── bin // ffmpeg主程序二进制目录├─── include // C/C++头文件目录├─── lib // 编译好的库文件目录├─── share // 文档目录 进入bin目录，执行 ./ffmpeg -version 查看当前版本的详细信息 默认情况下一般会报：libavdevice.so.57: cannot open shared object file: No such file or directory 原因是lib目录未加载到链接到系统库中，系统ld目录列表在/etc/ld.so.conf中，打开文件会发现，里面引用了/etc/ld.so.conf.d/下面所有的.conf文。 这时我们只需要创建一个文件并写入lib路径即可，执行命令：vim /etc/ld.so.conf.d/ffmpeg.conf 然后添加一行内容：/monchickey/ffmpeg/lib 之后保存并退出，然后执行 ldconfig 使配置生效，现在再次执行 ./ffmpeg -version 显示就正常了提示：可以根据需要将bin目录添加至环境变量中以保证任何时候都能使用ffmpeg命令 使用php代码实现视频封面图截取123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * 上传视频 * @return 视频路径 */function upload_video()&#123; if ($_FILES["file"]["error"] &gt; 0) &#123; $api-&gt;dataerror('视频上传错误!'); &#125; else &#123; $type = [ "video/rmvb", "video/wmv", "video/3gp", "video/mkv", "video/mp4", "video/mpg", "video/avi", "video/quicktime", "multipart/video", ]; if (in_array($_FILES["file"]["type"], $type)) &#123; if($_FILES["file"]["size"] &lt;= 20 * 1024 * 1024) &#123; $upload_path = 'uploads/video/file_name'; //建立文件夹 create($upload_path); $file_name = md5(uniqid(rand())); // 文件随机名字 $file_ext = strtolower(substr($_FILES["file"]["name"], strrpos($_FILES["file"]["name"], ".") + 1, strlen($_FILES["file"]["name"]))); // 获取文件后缀 $upload_path_file = $upload_path . $file_name . '.' . $file_ext; if (file_exists($upload_path_file)) &#123; echo '视频文件名以被占用, 请重新上传!'; &#125; else &#123; if (move_uploaded_file($_FILES["file"]["tmp_name"], $upload_path_file)) &#123; $video_path = $upload_path_file; // 视频路径 $item['video_path'] = $video_path; $face_name = $upload_path . $file_name . '.' . 'png'; //视频封面图 $pic_size = getVideoInfo($video_path); if ($pic_size['2'] &gt; 0) &#123; $str = "/monchickey/ffmpeg/bin/ffmpeg -i " . $video_path . " -y -f mjpeg -ss 1 -t 0.001 -s " . $pic_size[1] . "x" . $pic_size[0] . " " . $face_name; &#125; else &#123; $str = "/monchickey/ffmpeg/bin/ffmpeg -i " . $video_path . " -y -f mjpeg -ss 1 -t 0.001 -s " . $pic_size[0] . "x" . $pic_size[1] . " " . $face_name; &#125; system($str); if (file_exists($face_name)) &#123; $item['video_face_image'] = $name; &#125;else &#123; echo "视频封面图截取失败!"; &#125; return $item; &#125; else &#123; echo "视频文件上传失败!"; &#125; &#125; &#125;else &#123; echo "视频最大不能超过20M!"; &#125; &#125; else &#123; echo "视频格式错误!"; &#125; &#125;&#125;/** * 创建文件夹 * @param $dir 文件夹路径 */function create($dir)&#123; if( !is_dir($dir) )&#123; $temp = explode('/',$dir); $cur_dir = ''; for($i = 0; $i &lt; count($temp); $i++)&#123; $cur_dir .= $temp[$i].'/'; if(!is_dir($cur_dir))&#123; @mkdir($cur_dir,0777); &#125; &#125; &#125;&#125;/** * 处理视频文件文件截取封面图的信息 * @param $file 视频文件路径 */function getVideoInfo($file)&#123; $command = sprintf('/monchickey/ffmpeg/bin/ffmpeg -i "%s" 2&gt;&amp;1', $file); ob_start(); passthru($command); $info = ob_get_contents(); ob_end_clean(); if (preg_match("/Video: (.*?),(.*?),(.*?),(.*?),(.*?),(.*?),(.*?),(.*?)[,\s]/", $info, $match)) &#123; foreach ($match as $k =&gt; $m) &#123; if (strstr($m, 'x') &amp;&amp; $k &gt; 0) &#123; $size1 = explode('x', trim($m)); if (preg_match("/^\d*$/", $size1[0])) &#123; $size[0] = $size1[0]; if (preg_match("/^\d*$/", $size1[1])) &#123; $size[1] = $size1[1]; &#125; else &#123; $size2 = explode(' ', trim($size1[1])); $size[1] = $size2[0]; &#125; &#125; &#125; &#125; &#125; if (preg_match("/Side data:[,\s]/", $info, $match2)) &#123; $size[2] = 1; &#125; return $size;&#125; 参考 博客园 - 自由的web]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpstorm配置Xdebug]]></title>
    <url>%2Fposts%2Fxdebug%2F8d586dc9.html</url>
    <content type="text"><![CDATA[前言相信做为一名PHP开发的程序员对sublime这个编辑器不陌生吧，我之前用的就是这个编辑器，在每次有BUG反馈过来的时候，我都是用die去一步一步的断点打印输出找错误，看着是不是就很痛苦。后来知道了 phpstorm + xdebug，欣喜若狂，这简直是款调试代码的神器呀，幸福来的好突然。后来这篇文章就诞生了。 声明本篇文章将讲述的是如何使用 xdebug 配合 phpstorm 编辑器调试PHP程序 兼容 postman 什么是Xdebug?Xdebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况。 下载安装 下载 phpstorm 至于怎么去破解我想 这里 可以帮助你 下载对应版本的 Xdebug扩展 开始配置配置编辑器的php打开已经破解好的 phpstorm 的设置，找到 Languages &amp; Frameworks -&gt; PHP 选择自己当前正在使用的版本。 配置ServersName 随便填写，Host 和 Port 填写自己需要调试的项目域名以及端口，Debugger 默认的Xdebug就行 点击 Languages &amp; Frameworks -&gt; PHP -&gt; Debug 将Debug port 修改为 9001 点击 Languages &amp; Frameworks -&gt; PHP -&gt; Debug -&gt; DBGp Proxy 将IDE KEY换成当前PHP的IDE KEY填上自己网站的 host 和 port 查看IDE KEY需要打印自己的PHP信息echo phpinfo();然后在这里面找IDE KEY 配置 php.ini打开 php.ini 在最底部添加以下代码 1234567891011121314[xdebug]; XDEBUG Extension DLLzend_extension ="D:/wamp64/bin/php/php5.6.31/zend_ext/php_xdebug-2.5.5-5.6-vc11-x86_64.dll";xdebug.idekey="PHPSTORM"xdebug.remote_enable = onxdebug.profiler_enable = offxdebug.profiler_enable_trigger = offxdebug.profiler_output_name = cachegrind.out.%t.%pxdebug.profiler_output_dir ="D:/wamp64/tmp"xdebug.show_local_vars=0xdebug.remote_handler = dbgp; 设置xdebug的端口为9001, 要和编辑器设置的一致哦xdebug.remote_port = "9001" 安装chrome xdebug helper 扩展扩展地址： xdebug helper 运行监听配置（这步配置配置的是为了编辑器里的run需要的，在postman调试可以忽略此步骤）按照下图的配置完成后点击OK 开启监听 点击上面带虫子的小话筒 运行点击编辑器上面的小瓢虫，这时会自动弹出编辑器代码断点的地方，并打印了上面的变量 兼容 postman在项目中使用 postman 调试的时候在 header 添加如下配置 12KEY : CookieVALUE : XDEBUG_SESSION=PHPSTORM 点击 Send 后效果跟上面是一样的，自动弹出编辑器跳到断点的地方。]]></content>
      <categories>
        <category>xdebug</category>
      </categories>
      <tags>
        <tag>Xdebug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装配置hexo，部署+next主题]]></title>
    <url>%2Fposts%2Fhexo%2Fc14c7c98.html</url>
    <content type="text"><![CDATA[文章由来 以前没有写博客的习惯，也没写过几篇博客。之前有一次工作中找同事问一个前端问题，跑到他的办公桌前偶然的发现了这个”东西”。第一眼看上去给我的个人感觉很好，经过我对同事的仔细盘问后，在加以私下的了解，才知道这个博客是用 hexo (访问缓慢并且无样式，好像已弃用，最新的地址 hexo ) + next主题 搭建的。废话不多说了，Follow Me ! 安装安装前提在安装前，先确保电脑上已经安装了 Node.js 和 Git 环境。 安装Hexo1$ npm install -g hexo-cli 文档上是使用npm安装的，也有人用 yarn 安装的，博主说使用 yarn 安装要比 npm 要好，具体好在什么地方倒没试过。使用 yarn 安装的博主连接 ：代码小睿 。 建站初始化新建一个文件夹，名字随便起，比如我的叫 blog进入到新建的文件夹输入以下命令 1$ hexo init 初始化完成后，你会看到这样的一个文件目录结构 创建一个文件1$ hexo new post 第一篇文章 //在_post文件夹下创建一个名为 《第一篇文章》 的文件 生成静态文件1$ hexo generate // 可以简写成 hexo g 启动服务1$ hexo server // 可以简写成 hexo s 以上命令会生成一个 localhost:4000 的连接， 打开连接会看到自己博客的首页。 部署到线上GitHub 和 Gitee都支持Hexo静态网站的服务，我用的是Gitee。 首先到你的GitHub 或 Gitee 上去建立一个仓库，仓库名称最好是你自己的英文名称或者自创的名称，仓库创建好后，复制仓库的地址 打开本地的 _config.yml 配置文件，找到最下面的 deploy 选项. 123deploy: type: git repo: https://gitee.com/***/*** // 刚刚创建的仓库连接地址 注意：冒号后面一定要有一个空格 安装 hexo-deployer-git 自动部署工具。 1$ npm install hexo-deployer-git --save 上传到线上安装完成自动部署工具后，使用命令上传到线上 1$ hexo deploy // 简写 hexo d 第一次上传会提示你输入GitHub 或者 Gitee 的账号密码，确认后等待一会会提示你发布成功；这时打开码云，找到刚刚项目分支，点击服务选择Gitee Pages，然后就可以看到线上的一个连接。点击进入连接 https://hsweet.gitee.io 就可以看到线上的博客了。 主题安装Next主题1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 我安装的是 6.0.x 的 NexT ，但在 NexT 官网上提供的还是 5.1.x 的安装命令和文档，因为 6.0.x 和 5.1.x 的配置有所不同，建议第一次练习搭建还是使用 5.1.x ，熟悉配置文档后，再用 6.0.x 。 修改 _config.yml 文件里 theme 配置： 1theme: next 配置虽然我安装的是 6.0.x ，但大部分还是可以根据 NexT 主题配置 文档来修改，以下会介绍一些文档中没有提及的设置。 区分两个配置文件 :站点配置文件 _config.yml主题配置文件 themes/next/_config.yml 设置网站语言打开 站点配置 找到 language 修改 1language: zh-CN 开启导航打开 主题配置 找到 menu ，将需要开启的导航前面的 # 删掉 123456789menu: home: / || home // 首页 about: /about/ || user // 关于我 tags: /tags/ || tags // 标签 categories: /categories/ || th // 分类 archives: /archives/ || archive // 归档 #schedule: /schedule/ || calendar // 日程表 #sitemap: /sitemap.xml || sitemap // 站点地图 commonweal: /404.html || heartbeat // 404公益 这个时候会发现网站上已经能看到导航了，但点击却提示找不到页面。 这时需要去新建对应的页面，比如新建 标签 页： 1$ hexo new page &quot;tags&quot; 新建好后会在 source/tags/index.md 看到刚新建的文件，在文件随便增加一句话重新编译生成试试。 更多配置请参考文档 : Next主题官方文档 总结每次新建的页面文件，修改文件 或 修改配置的时候只需要以下三个命令就ok了（甚至我觉得只需要这三个命令就行了） 12345$ hexo generate // 编译 简写: hexo g$ hexo server // 生成临时文件并给出一个本地连接 简写: hexo s$ hexo deploy // 把临时生成的文件上传到服务器 参考 Hexo文档 Next主题文档 搭建hexo + next主题博客教程]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
